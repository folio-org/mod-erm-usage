package org.folio.rest.impl;

import static io.vertx.core.Future.failedFuture;
import static io.vertx.core.Future.succeededFuture;
import static org.folio.rest.RestVerticle.OKAPI_HEADER_PREFIX;

import io.vertx.core.AsyncResult;
import io.vertx.core.Context;
import io.vertx.core.Handler;
import io.vertx.core.Promise;
import io.vertx.core.Vertx;
import io.vertx.core.http.impl.HttpServerImpl;
import io.vertx.core.impl.VertxImpl;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.impl.RouterImpl;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import javax.ws.rs.core.Response;
import org.apache.commons.collections4.map.CaseInsensitiveMap;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.folio.okapi.common.XOkapiHeaders;
import org.folio.rest.resource.interfaces.PostDeployVerticle;

public class PostDeployImpl implements PostDeployVerticle {

  private static final Logger log = LogManager.getLogger();

  private static CaseInsensitiveMap<String, String> getOkapiHeadersFromRoutingContext(
      RoutingContext rctx) {
    return rctx.request().headers().entries().stream()
        .filter(e -> e.getKey().toLowerCase().startsWith(OKAPI_HEADER_PREFIX))
        .collect(
            Collectors.toMap(
                Map.Entry::getKey, Map.Entry::getValue, (v1, v2) -> v2, CaseInsensitiveMap::new));
  }

  @Override
  public void init(Vertx vertx, Context context, Handler<AsyncResult<Boolean>> resultHandler) {
    VertxImpl vertxImpl = (VertxImpl) vertx;
    int port = context.config().getInteger("http.port", 8081);
    List<HttpServerImpl> httpServers =
        vertxImpl.sharedHttpServers().values().stream()
            .filter(s -> s.actualPort() == port)
            .toList();
    if (httpServers.size() != 1) {
      resultHandler.handle(failedFuture("Unable to find HTTP server"));
      return;
    }

    // setup a route handler for multipart/form-data uploads
    // by setting the order to 0, we ensure that this handler is executed instead of the RMB handler
    // RMB does not support multipart/form-data uploads
    // this handler delegates the API call to the method generated by RMB
    RouterImpl router = (RouterImpl) httpServers.get(0).requestHandler();
    router
        .postWithRegex("/counter-reports/multipartupload/provider/([^/]+)/?")
        .order(0)
        .handler(
            rctx -> {
              log.info("invoking postCounterReportsMultipartuploadProviderById");
              String id = rctx.pathParams().values().stream().findFirst().orElse(null);
              Boolean overwrite =
                  rctx.queryParam("overwrite").stream()
                      .findFirst()
                      .map(s -> s.equals("true"))
                      .orElse(false);
              CaseInsensitiveMap<String, String> okapiHeaders =
                  getOkapiHeadersFromRoutingContext(rctx);

              if (okapiHeaders.get(XOkapiHeaders.TENANT) == null) {
                endResponse(rctx, Response.status(400).entity("Tenant must be set").build());
                return;
              }

              Promise<Response> promise = Promise.promise();
              new CounterReportAPI()
                  .postCounterReportsMultipartuploadProviderById(
                      id,
                      overwrite,
                      null,
                      rctx,
                      okapiHeaders,
                      promise,
                      rctx.vertx().getOrCreateContext());
              promise
                  .future()
                  .onSuccess(resp -> endResponse(rctx, resp))
                  .onFailure(
                      t -> endResponse(rctx, Response.serverError().entity(t.toString()).build()));
            });

    resultHandler.handle(succeededFuture(true));
  }

  private void endResponse(RoutingContext rctx, Response response) {
    rctx.response().setStatusCode(response.getStatus());
    response.getStringHeaders().forEach((k, v) -> rctx.response().putHeader(k, v));
    if (response.getEntity() instanceof String entity) {
      rctx.response().end(entity);
    } else {
      rctx.response().end();
    }
  }
}
